.TH "lib/menuoption.h" 3 "Fri Jan 6 2023" "greenland" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/menuoption.h
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBMenuOption\fP \fBMenuOption\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBMenuOption\fP { \fBPLANT_TREE\fP = 1, \fBQUERY_TREE\fP, \fBUPDATE_TREE\fP, \fBDISPLAY_ALL_TREES\fP, \fBEXIT_PROGRAM\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBmoption_handle\fP (int new_sockfd, int semid, char *cli_addr, \fBMenuOption\fP mo)"
.br
.ti -1c
.RI "void \fBmoption_display\fP (\fBMenuOption\fP *opt)"
.br
.ti -1c
.RI "const char * \fBgetMenuOptionName\fP (enum \fBMenuOption\fP op)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
2022-11-16 23:05:32 PM +0800 
.RE
.PP

.PP
Definition in file \fBmenuoption\&.h\fP\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBMenuOption\fP \fBMenuOption\fP"
MenuOption defines available options in the client menu 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBMenuOption\fP"
MenuOption defines available options in the client menu 
.PP
Definition at line 11 of file menuoption\&.h\&.
.PP
.nf
11                         {
12   PLANT_TREE = 1,
13   QUERY_TREE,
14   UPDATE_TREE,
15   DISPLAY_ALL_TREES,
16   EXIT_PROGRAM
17 } MenuOption;
.fi
.SH "Function Documentation"
.PP 
.SS "const char* getMenuOptionName (enum \fBMenuOption\fP op)"
Get menu option into readable string
.PP
\fBParameters\fP
.RS 4
\fIop\fP A menu option
.RE
.PP
\fBReturns\fP
.RS 4
A string that specifies the name of menu option, NULL if the state is unknown 
.RE
.PP

.PP
Definition at line 103 of file menuoption\&.c\&.
.PP
.nf
104 {
105   switch (op) {
106     case PLANT_TREE:
107       return "Plant Tree";
108 
109     case QUERY_TREE:
110       return "Query Tree";
111 
112     case UPDATE_TREE:
113       return "Update Tree";
114 
115     case DISPLAY_ALL_TREES:
116       return "Display All Trees";
117 
118     case EXIT_PROGRAM:
119       return "Exit Program";
120 
121     default:
122       return (char*)0;
123   }
124 }
.fi
.SS "void moption_display (\fBMenuOption\fP * opt)"
Display menu options
.PP
\fBParameters\fP
.RS 4
\fIopt\fP A MenuOption got from user's input 
.RE
.PP

.PP
Definition at line 74 of file menuoption\&.c\&.
.PP
.nf
75 {
76   printf("  ________                               \&.__                       \&.___ \n");
77   printf(" /  _____/_______   ____   ____    ____  |  |  _____     ____    __| _/ \n");
78   printf("/   \\  ___\\_  __ \\_/ __ \\_/ __ \\  /    \\ |  |  \\__  \\   /    \\  / __ |  \n");
79   printf("\\    \\_\\  \\|  | \\/\\  ___/\\  ___/ |   |  \\|  |__ / __ \\_|   |  \\/ /_/ |  \n");
80   printf(" \\______  /|__|    \\___  >\\___  >|___|  /|____/(____  /|___|  /\\____ |  \n");
81   printf("        \\/             \\/     \\/      \\/            \\/      \\/      \\/  \n\n");
82 
83   printf("Welcome to greenland, a place to plant tree!\n\n");
84   printf("We don't have any affiliation to the Greenland government, but if \n"
85          "you can plant a tree there, we are more than welcome! :)\n");
86 
87   printf("################################\n");
88   printf("#                              #\n");
89   printf("#            MENU              #\n");
90   printf("#                              #\n");
91   printf("################################\n\n");
92   printf("\t1\&. To plant a tree\n");
93   printf("\t2\&. To query a tree\n");
94   printf("\t3\&. To update a tree's status\n");
95   printf("\t4\&. To display all the tree\n");
96   printf("\t5\&. Exit\n");
97   printf("(Choose a service needed according to the number)\n\n");
98   printf("Option: ");
99   scanf("%d", (int*)opt);
100   system("clear");
101 }
.fi
.SS "char* moption_handle (int new_sockfd, int semid, char * cli_addr, \fBMenuOption\fP mo)"
Handles menu option
.PP
\fBParameters\fP
.RS 4
\fIsockfd\fP Socket number of client 
.br
\fIsemid\fP Semaphore's id 
.br
\fImo\fP A MenuOption enum to be handle
.RE
.PP
\fBReturns\fP
.RS 4
0 if the handling succeeded, -1 if failed 
.RE
.PP

.PP
Definition at line 31 of file menuoption\&.c\&.
.PP
.nf
32 {
33   char buffer[BUFFER_SIZE];
34   char* msg = malloc(1024);
35   Tree tree;
36 
37   switch (mo) {
38     case PLANT_TREE:
39       p(semid); // lock the semaphore for writing
40       plant_tree_server(FILENAME, tree, new_sockfd, buffer);
41       v(semid); // unlock the semaphore after writing
42       sprintf(msg, "Client [%s]: %s Process Done\&.", cli_addr, getMenuOptionName(mo));
43       return msg;
44 
45     case QUERY_TREE:
46       query_tree_server(FILENAME, tree, new_sockfd, buffer);
47       sprintf(msg, "Client [%s]: %s Process Done\&.", cli_addr, getMenuOptionName(mo));
48       return msg;
49 
50     case UPDATE_TREE:
51       p(semid); // lock the semaphore for writing
52       /* critical section */
53       /* invoke update_tree_server function */
54       update_tree_server(FILENAME, tree, new_sockfd, buffer);
55       v(semid); // unlock the semaphore after writing
56       sprintf(msg, "Client [%s]: %s Process Done\&.", cli_addr, getMenuOptionName(mo));
57       return msg;
58 
59     case DISPLAY_ALL_TREES:
60       display_all_tree(FILENAME, new_sockfd, buffer);
61       sprintf(msg, "Client [%s]: %s Process Done\&.", cli_addr, getMenuOptionName(mo));
62       return msg;
63 
64     case EXIT_PROGRAM:
65       sprintf(msg, "Client [%s]: Exited program\&.", cli_addr);
66       return msg;
67 
68     default:
69       sprintf(msg, "Option %d not supported\n", mo);
70       return msg;
71   }
72 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for greenland from the source code\&.
